<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
 <script>

  // ES6 ECMA2015를 의미한다.

  /*
    선언 키워드
    1. let
      1) 블록 레벨 { }의 스코프를 가진다.
      2) 초기화를 생략할 수 있다.
      3) 재선언이 불가능하다.
      4) 지역 변수 용도로 사용한다.

    2. const
     1) 블록 레벨 { }의 스코프를 가진다.
     2) 반드시 초기화가 필요하다.
     3) 재선언이 불가능하다.
     4) 상수 용도로 사용한다.
      
  */
 
   // let
   var array = [10, 'A',1.5];
   for(let i = 0; i < array.length; i++){
    console.log(array[i]);
   }
   
   // const
   const func = function(){
    console.log('func 실행');
   }

 </script>
 
 <script>
   
  /*
    back tick(`) 지원
    1. Multiple-line 문자열 지원
    2. 템플릿 리터럴(template literals) 지원 
  */

   let str = `안녕하세요
반갑습니다`;
   console.log(str);

   const name = '고길동';
   console.log('내 이름은 ' + name + '입니다.');
   console.log(`내 이름은 ${name}입니다.`); // 템플릿 리터럴

 </script>

 <script>
  
   /*
     구조 분해 
     1. 객체는 '속성:값' 으로 데이터를 구성한다.
     2. 객체를 구성하는 각 속성의 값을 일반 변수로 쉽게 가져올 수 있다.
     3. 배열의 요소도 일반 변수로 하나씩 쉽게 가져올 수 있다.
   */

   // 객체 구조 분해
   const car = {
    maker: 'bmw',
    model: '5시리즈'
   };
   // 구조 분해 할당
   var {maker, model} = car;

   console.log(maker, model);

   // 배열 구조 분해

   const colors = ['red','green', 'blue'];

  //  var a = colors[0];
  //  var b = colors[1];
  //  var c = colors[2];

   let [a,b,c] = colors;
   console.log(a,b,c);

 </script>

  <script>
   
   /*
      화살표 함수 (arrow function)
      1. 익명 함수의 다른 표현 방식이다.
      2. 형식
        1) 화살표 함수를 이용한 함수 표현식
           const 함수이름 = ([매개변수]) => { 
             
           }
        2) 함수 호출 
          함수이름([인자]);   
   */

    const myFunc1 = () => {
       console.log('myFunc 실행');
    }
    myFunc1();

    const myFunc2 = () => 'hello world'; // return 만 존재하는 경우 return 키워드 생략 가능
    
    console.log(myFunc2());
  </script>
     
  <script>

     /*
        말 줄임표(..., 전개 연산자) 지원
        1. 전달되는 인자 개수가 일정하지 않을 때 사용한다.
        2. 배열로 처리한다.
     */

     // 말 줄임표(..., 전개 연산자)
     const getTotal = (...numbers) => { // numbers는 배열로 처리한다.
           var total = 0;
           for(var i = 0; i < numbers.length; i++){
            total += numbers[i];
           }
           return total;
        };
        console.log(getTotal(1,2,3));
        console.log(getTotal(1,2,3,4));
</script>

<script>

  /* 비동기 작업 : 응답을 기다리지 않는다. */

  let albumId; // 초기화가 없으면 undefined
  const xhr = new XMLHttpRequest();
  xhr.open('GET', 'https://jsonplaceholder.typicode.com/photos/1');
  xhr.send();
  xhr.addEventListener('readystatechange', () => {
    if(xhr.readyState !== XMLHttpRequest.DONE)
    return;
    if(xhr.status !== 200)
    return;
  let album = JSON.parse(xhr.responseText);
  albumId = album.albumId;
  })
  console.log('albumId:',albumId); // albumId = 1 을 기대하지만 -> 비동기 작업의 응답을 기다려주지 않고 바로 실행해버려 undefined
</script> 

<script>

  /*
    Promise
    1. 비동기 작업이 맞이할 미래의 완료 또는 실패에 따른 그 결과값을 나타내는 객체이다.
    2. 미래의 어떤 시점에 결과를 제공하겠다는 '약속'을 반환하는 방식으로 동작한다.
    3. Promise 상태
      1) pending   : 초기 상태(이행도 아니고 거부도 아닌 상태)
      2) fulfilled : 이행 상태(비동기 작업 성공)
      3) reject    : 거부 상태(비동기 작업 실패)
    4. Promise 생성자
      1) Promise를 지원하지 않는 함수를 Promise로 만들 때 사용한다.
      2) 형식 
        new Promise(excutor)
      3) excutor : 실행 함수
        (1) 인자가 resole,reject인 실행 함수이다.
        (2) resolve는 Promise 이행 함수이고, reject은 Promise 거부 함수이다.  
    5. Promise의 then() 메소드
      1) Promise 객체가 호출할 수 있다.
      2) Promise 이행 함수와 Promise 거부 함수를 콜백으로 추가한다.
      3) 콜백이 호출될 경우 그 반환값을 처리하고, 호출되지 않는 경우 처리된 상태와 값을 그대로 가진 새로운 Promise를 반환한다.
      4) 형식
         then(() => { // 이행 함수 } , [() => { // 거부 함수 }])  -> 거부 함수는 생략 가능    
  */

  let albumId2;
  const myPromise = new Promise((resolve, reject)=>{
    const xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://jsonplaceholder.typicode.com/photos/1');
    xhr.send();
    xhr.addEventListener('readystatechange', () => {
      if(xhr.readyState !== XMLHttpRequest.DONE)
      return;
      if(xhr.status !== 200)
        reject(xhr.statusText); // Promise 거부 함수 실행 (거부 사유를 전달할 수 있다.)
      resolve(JSON.parse(xhr.responseText)); // Promise 이행 함수 실행 (응답 결과를 전달할 수 있다.)
      
    }) 
  });
  myPromise
  .then((resData) => {
     console.log(resData);
     albumId2 = resData.albumId;
     console.log('albumId2', albumId2);
  }, (msg) => {
     console.log(msg);
  })
</script>
</body>
</html>